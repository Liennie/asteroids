package main

import (
	"fmt"
	"strings"
)

type Point struct {
	x, y int
}

func (this Point) Add(other Point) Point {
	return Point{
		x: this.x + other.x,
		y: this.y + other.y,
	}
}

func (this Point) Sub(other Point) Point {
	return Point{
		x: this.x - other.x,
		y: this.y - other.y,
	}
}

func (p Point) String() string {
	return fmt.Sprintf("%d,%d", p.x, p.y)
}

func main() {
	// data := `
	// 	..#..###....#####....###........#
	// 	.##.##...#.#.......#......##....#
	// 	#..#..##.#..###...##....#......##
	// 	..####...#..##...####.#.......#.#
	// 	...#.#.....##...#.####.#.###.#..#
	// 	#..#..##.#.#.####.#.###.#.##.....
	// 	#.##...##.....##.#......#.....##.
	// 	.#..##.##.#..#....#...#...#...##.
	// 	.#..#.....###.#..##.###.##.......
	// 	.##...#..#####.#.#......####.....
	// 	..##.#.#.#.###..#...#.#..##.#....
	// 	.....#....#....##.####....#......
	// 	.#..##.#.........#..#......###..#
	// 	#.##....#.#..#.#....#.###...#....
	// 	.##...##..#.#.#...###..#.#.#..###
	// 	.#..##..##...##...#.#.#...#..#.#.
	// 	.#..#..##.##...###.##.#......#...
	// 	...#.....###.....#....#..#....#..
	// 	.#...###..#......#.##.#...#.####.
	// 	....#.##...##.#...#........#.#...
	// 	..#.##....#..#.......##.##.....#.
	// 	.#.#....###.#.#.#.#.#............
	// 	#....####.##....#..###.##.#.#..#.
	// 	......##....#.#.#...#...#..#.....
	// 	...#.#..####.##.#.........###..##
	// 	.......#....#.##.......#.#.###...
	// 	...#..#.#.........#...###......#.
	// 	.#.##.#.#.#.#........#.#.##..#...
	// 	.......#.##.#...........#..#.#...
	// 	.####....##..#..##.#.##.##..##...
	// 	.#.#..###.#..#...#....#.###.#..#.
	// 	............#...#...#.......#.#..
	// 	.........###.#.....#..##..#.##...
	// `
	data := `
		.#..##.###...#######
		##.############..##.
		.#.######.########.#
		.###.#######.####.#.
		#####.##.#.##.###.##
		..#####..#.#########
		####################
		#.####....###.#.#.##
		##.#################
		#####.##.###..####..
		..######..##.#######
		####.##.####...##..#
		.#####..#.######.###
		##...#.##########...
		#.##########.#######
		.####.#.###.###.#.##
		....##.##.###..#####
		.#.#.###########.###
		#.#.#.#####.####.###
		###.##.####.##.#..##
	`

	m := map[Point]bool{}

	for y, row := range strings.Split(strings.TrimSpace(data), "\n") {
		for x, c := range strings.Split(strings.TrimSpace(row), "") {
			m[Point{x, y}] = c == "#"
		}
	}

	max := 0
	at := Point{}

	for pos, asteroid := range m {
		if !asteroid {
			continue
		}

		s := map[Point]bool{}
		cont := true

		try := func(p Point, v Point) (f bool) {
			p = p.Add(v)
			if _, ok := s[p]; ok {
				return false
			}

			a, ok := m[p]
			for ok {
				cont = true
				s[p] = true
				if a {
					f = true
				}

				p = p.Add(v)
				a, ok = m[p]
			}

			return
		}

		count := 0

		for off := 1; cont; off++ {
			cont = false

			for x := -off; x <= off; x++ {
				if try(pos, Point{x, off}) {
					count += 1
				}
				if try(pos, Point{x, -off}) {
					count += 1
				}
			}

			for y := 1 - off; y <= off-1; y++ {
				if try(pos, Point{off, y}) {
					count += 1
				}
				if try(pos, Point{-off, y}) {
					count += 1
				}
			}
		}

		if count > max {
			max = count
			at = pos
		}
	}

	fmt.Printf("%d at %v\n", max, at)
}
